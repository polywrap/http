"""
This type stub file was generated by pyright.
"""

import inspect
import sys
import types
from __future__ import annotations
from typing import Any, Callable, Generic, NoReturn, ParamSpec, TypeVar, Union, cast, overload
from typing_extensions import ParamSpec

"""
A simple Rust like Result type for Python 3.

This project has been forked from the https://github.com/rustedpy/result.
"""
if sys.version_info[: 2] >= (3, 10):
    ...
else:
    ...
T = TypeVar("T", covariant=True)
U = TypeVar("U")
F = TypeVar("F")
P = ...
R = TypeVar("R")
TBE = TypeVar("TBE", bound=BaseException)
class Ok(Generic[T]):
    """
    A value that indicates success and which stores arbitrary data for the return value.
    """
    _value: T
    __match_args__ = ...
    __slots__ = ...
    @overload
    def __init__(self) -> None:
        ...
    
    @overload
    def __init__(self, value: T) -> None:
        ...
    
    def __init__(self, value: Any = ...) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def __ne__(self, other: Any) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def is_ok(self) -> bool:
        ...
    
    def is_err(self) -> bool:
        ...
    
    def ok(self) -> T:
        """
        Return the value.
        """
        ...
    
    def err(self) -> None:
        """
        Return `None`.
        """
        ...
    
    @property
    def value(self) -> T:
        """
        Return the inner value.
        """
        ...
    
    def expect(self, _message: str) -> T:
        """
        Return the value.
        """
        ...
    
    def expect_err(self, message: str) -> NoReturn:
        """
        Raise an UnwrapError since this type is `Ok`
        """
        ...
    
    def unwrap(self) -> T:
        """
        Return the value.
        """
        ...
    
    def unwrap_err(self) -> NoReturn:
        """
        Raise an UnwrapError since this type is `Ok`
        """
        ...
    
    def unwrap_or(self, _default: U) -> T:
        """
        Return the value.
        """
        ...
    
    def unwrap_or_else(self, op: Callable[[Exception], T]) -> T:
        """
        Return the value.
        """
        ...
    
    def unwrap_or_raise(self) -> T:
        """
        Return the value.
        """
        ...
    
    def map(self, op: Callable[[T], U]) -> Result[U]:
        """
        The contained result is `Ok`, so return `Ok` with original value mapped to
        a new value using the passed in function.
        """
        ...
    
    def map_or(self, default: U, op: Callable[[T], U]) -> U:
        """
        The contained result is `Ok`, so return the original value mapped to a new
        value using the passed in function.
        """
        ...
    
    def map_or_else(self, default_op: Callable[[], U], op: Callable[[T], U]) -> U:
        """
        The contained result is `Ok`, so return original value mapped to
        a new value using the passed in `op` function.
        """
        ...
    
    def map_err(self, op: Callable[[Exception], F]) -> Result[T]:
        """
        The contained result is `Ok`, so return `Ok` with the original value
        """
        ...
    
    def and_then(self, op: Callable[[T], Result[U]]) -> Result[U]:
        """
        The contained result is `Ok`, so return the result of `op` with the
        original value passed in
        """
        ...
    
    def or_else(self, op: Callable[[Exception], Result[T]]) -> Result[T]:
        """
        The contained result is `Ok`, so return `Ok` with the original value
        """
        ...
    


class Err:
    """
    A value that signifies failure and which stores arbitrary data for the error.
    """
    __match_args__ = ...
    __slots__ = ...
    def __init__(self, value: Exception) -> None:
        ...
    
    @classmethod
    def from_str(cls, value: str) -> Err:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def __ne__(self, other: Any) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def is_ok(self) -> bool:
        ...
    
    def is_err(self) -> bool:
        ...
    
    def ok(self) -> None:
        """
        Return `None`.
        """
        ...
    
    def err(self) -> Exception:
        """
        Return the error.
        """
        ...
    
    @property
    def value(self) -> Exception:
        """
        Return the inner value.
        """
        ...
    
    def expect(self, message: str) -> NoReturn:
        """
        Raises an `UnwrapError`.
        """
        ...
    
    def expect_err(self, _message: str) -> Exception:
        """
        Return the inner value
        """
        ...
    
    def unwrap(self) -> NoReturn:
        """
        Raises an `UnwrapError`.
        """
        ...
    
    def unwrap_err(self) -> Exception:
        """
        Return the inner value
        """
        ...
    
    def unwrap_or(self, default: U) -> U:
        """
        Return `default`.
        """
        ...
    
    def unwrap_or_else(self, op: Callable[[Exception], T]) -> T:
        """
        The contained result is ``Err``, so return the result of applying
        ``op`` to the error value.
        """
        ...
    
    def unwrap_or_raise(self) -> NoReturn:
        """
        The contained result is ``Err``, so raise the exception with the value.
        """
        ...
    
    def map(self, op: Callable[[T], U]) -> Result[U]:
        """
        Return `Err` with the same value
        """
        ...
    
    def map_or(self, default: U, op: Callable[[T], U]) -> U:
        """
        Return the default value
        """
        ...
    
    def map_or_else(self, default_op: Callable[[], U], op: Callable[[T], U]) -> U:
        """
        Return the result of the default operation
        """
        ...
    
    def map_err(self, op: Callable[[Exception], Exception]) -> Result[T]:
        """
        The contained result is `Err`, so return `Err` with original error mapped to
        a new value using the passed in function.
        """
        ...
    
    def and_then(self, op: Callable[[T], Result[U]]) -> Result[U]:
        """
        The contained result is `Err`, so return `Err` with the original value
        """
        ...
    
    def or_else(self, op: Callable[[Exception], Result[T]]) -> Result[T]:
        """
        The contained result is `Err`, so return the result of `op` with the
        original value passed in
        """
        ...
    


Result = Union[Ok[T], Err]
class UnwrapError(Exception):
    """
    Exception raised from ``.unwrap_<...>`` and ``.expect_<...>`` calls.

    The original ``Result`` can be accessed via the ``.result`` attribute, but
    this is not intended for regular use, as type information is lost:
    ``UnwrapError`` doesn't know about both ``T`` and ``E``, since it's raised
    from ``Ok()`` or ``Err()`` which only knows about either ``T`` or ``E``,
    not both.
    """
    _result: Result[Any]
    def __init__(self, result: Result[Any], message: str) -> None:
        ...
    
    @property
    def result(self) -> Result[Any]:
        """
        Returns the original result.
        """
        ...
    


